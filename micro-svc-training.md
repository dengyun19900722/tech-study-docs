### 0. 参考博客

| 博客地址                                                     | 博客简介                                 | 备注 |
| ------------------------------------------------------------ | ---------------------------------------- | ---- |
| https://www.zhihu.com/question/65502802                      | 架构演进案例                             |      |
| https://www.cnblogs.com/li-peng/p/10997140.html              | 雪崩效应详解                             |      |
| https://blog.csdn.net/zeb_perfect/article/details/54135506                   https://juejin.im/post/5c9a67ac6fb9a070cb24bf34 | 缓存穿透，缓存击穿，缓存雪崩解决方案分析 |      |
| https://blog.csdn.net/qw_xingzhe/article/details/82263251    | 微服务架构图                             |      |
| https://cloud.tencent.com/developer/article/1081521          | 基于微服务架构的技术实践                 |      |
| https://bbs.huaweicloud.com/forum/thread-1762-1-1.html       | 华为微服务架构设计与实践                 |      |
| https://www.infoq.cn/article/microservice-event-choreographies | 协同编排 > 业务流程实现方案              |      |
| https://my.oschina.net/crooner/blog/644825                   | Richardson成熟度模型 - REST成熟度模型    |      |

（1）

​        还有一种抽象出公共逻辑的方法是把这些公共逻辑做成**公共的框架库（ds-frame）**。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。*
​       数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。*
​	微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些**公共的功能**——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。**（避免重复造轮子）**

​	从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。

（2）微服务痛点

​		以往单体应用，排查问题通常是看一下日志，研究错误信息和调用堆栈。而**微服务架构整个应用分散成多个服务，定位故障点非常困难**。

​	**在微服务架构中，一个服务故障可能会产生雪崩效应，导致整个系统故障**。

（3）常见的导致雪崩的情况有以下几种：

- 程序bug导致服务不可用，或者运行缓慢；（遇到最多）
- 缓存击穿，导致调用全部访问某服务，导致down掉
- 访问量的突然激增。
- 硬件问题，这感觉只能说是点背了⊙︿⊙。

### 0. 好的开篇

   场景分享：A服务挂掉 > B,C,D,E,F均不可用 > 各方开始排查，催促，不断的接电话 > 解决不及时就是各种投诉；

### 1. 微服务

http://r12f.com/posts/reading-time-building-microservices/

顶级公共能力层

子级公共能力层

业务层

快速迭代、避免重复造轮子

​	讲讲微服务带来的好处 -> 引出问题（痛点） -> 解决方案

#### 1.1 什么是微服务？

​	微服务就是一些协同工作的小而自治的服务；

（1）很小，专注做好一件事（内聚性 > 如何确定服务边界 ？）

​	业务边界决定服务边界；

​    拆分程度依据：

​    a）个人感觉，不再感觉服务过大；

​    b）团队结构，小团队能独立维护；

​    c）服务治理能力：

​         服务越小 > 独立性越强，服务治理越复杂；

（2）自治性（解耦性）

​		服务之间通过API > 技术无关性（网络调用）通信，实现服务之间的隔离性，避免紧耦合；

​		场景1：服务A采用Http Rest来暴露Api接口，服务2采用protcol buffer，服务3采用java Rmi；那么服务消费方想要调用服务则需要实现3中协议；

#### 1.2 微服务全生命周期

![clipboard.png](https://segmentfault.com/img/bVbecHN?w=640&h=367)



​	采用微服务不仅仅是写几个微服务就万事大吉了，微服务的部署、运营，微服务之间的调用、协作，微服务版本管理、上线下线，以及微服务体系的规划、每个微服务的设计构建、测试，都是微服务体系中重要的内容。也是基于此考虑，我们将微服务整个生命周期过程任务事项梳理定义为规划、构建、协同、测试、部署、发布、运营、下线和治理等：

![1573371103684](C:\Users\dengy\AppData\Roaming\Typora\typora-user-images\1573371103684.png)

##### 1.2.1 微服务规划（如何拆分）

##### 1.2.2 微服务构建（单个微服务的设计构建）

##### 1.2.3 微服务协同（微服务之间的网络调用）

##### 1.2.4 微服务测试

##### 1.2.5 微服务部署

##### 1.2.6 微服务发布

##### 1.2.7 微服务运营

##### 1.2.8 微服务下线

##### 1.2.9 微服务治理

### 2. 容器化

​	https://www.toutiao.com/i6753476749108969998/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1572747767&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=20191103102246010026077087371817FD&group_id=6753476749108969998

（1）为什么要容器化？

​		容器技术最初是为了解决运行环境的不一致问题而产生的，随着不断地发展，围绕容器技术衍生出来越来越多的新方向。

​		容器化是软件开发的一种方法，通过该方法可将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像。 容器化应用程序可以作为一个单元进行测试，并可以作为容器映像实例部署到主机操作系统 (OS)。

​		就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。

​		容器还会在共享 OS 上将应用程序彼此隔离开。 容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。 因此，容器的占用比虚拟机 (VM) 映像小得多。

​		每个容器可以运行整个 Web 应用或服务，如图 2-1 所示。 在此示例中，Docker 主机是容器主机，而 App1、App2、Svc 1 和 Svc 2 是容器化应用程序或服务。

![1574645680236](C:\Users\dengy\AppData\Roaming\Typora\typora-user-images\1574645680236.png)

​																	**图 2-1**. 在一个容器主机上运行多个容器

​		容器化的另一个优势在于可伸缩性。 通过为短期任务创建新容器，可以快速扩大。 从应用程序的角度来看，实例化映像（创建容器）类似于实例化 服务或 Web 应用等进程。 但出于可靠性考虑，在多个主机服务器上运行同一映像的多个实例时，通常要使每个容器（映像实例）在不同容错域中的不同主机服务器或 VM 中运行。

​		总而言之，容器在整个应用程序生命周期工作流中提供以下优点：隔离性、可移植性、灵活性、可伸缩性和可控性。 最重要的优点是可在开发和运营之间提供隔离。

（2）docker带来了什么？

- 面向产品：产品交付
- 面向开发：简化环境配置
- 面向测试：多版本测试
- 面向运维：环境一致性
- 面向架构：自动化扩容（微服务）

（3）它为什么能做到这些？

#### 2.1 Docker

https://yeasy.gitbooks.io/docker_practice/content/

##### 2.1.1 应用层面

1. ###### 3个概念：镜像、容器、仓库

   1）image - 镜像

   ​		docker镜像就是一个只读模板，比如，一个镜像可以包含一个完整的centos，里面仅安装apache或用户的其他应用，镜像可以用来创建docker容器，另外docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下周一个已经做好的镜像来直接使用；

   2）container - 容器

   ​		docker利用容器来运行应用，容器是从镜像创建的运行实例，它可以被启动，开始、停止、删除、每个容器都是互相隔离的，保证安全的平台，可以吧容器看做是要给简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行再其中的应用程序；

   3）repostory - 仓库

   ​		仓库是集中存储镜像文件的沧桑，registry是仓库主从服务器，实际上参考注册服务器上存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）；

   ​		仓库分为两种，公有参考，和私有仓库，最大的公开仓库是docker Hub，存放了数量庞大的镜像供用户下周，国内的docker pool，这里仓库的概念与Git类似，registry可以理解为github这样的托管服务。

2. ###### 样例：通过制作一个镜像理解Docker的基础操作？

##### 2.1.2 底层实现

1. 架构图：runC、Containerd、
2. 分层模式、增量更新
3. 架构图：



**本阶段输入为：**微服务

**本阶段输出为：**大批量的容器

### 3. 容器编排

​	https://www.servicemesher.com/blog/journey-from-containerization-to-orchestration-and-beyond/

​	https://ithelp.ithome.com.tw/articles/10192193（容器化、容器编排）

（1）k8s如何将一组对象关联起来？

​            label + annotation

（2）什么是容器编排？

​		支持應用程序的容器的部署和組織稱為**容器編排**，這是通過容器編排工具完成的。一些流行的開源調用容器編排工具包括**Kubernetes**、Docker Swarm和LXC。

（2）容器编排做了什么？

​		在容器运行的正式环境 (production) 中，我们必须要确保应用程序能够支持以下特性 ：

- `可容错`     ：当某些错误情况发生时，仍能保持系统能运作 
- `可扩展`：在需要的時候能增加，在不需要的時候能减少
- `能充分并有效使用资源`：很重要！因为资源是要钱的！
- `容器间能互相沟通`：能察觉容器加入或刪除
- `可提供管道供外部存取`：如果外部不能存取，可就真是孤芳自賞了
- `不需要停机就能更新或回滚 (rollback)`：玩游戏的時候，大家应该最讨厌维修时间了吧

（3）它为什么能做到这些？

![img](https://iximiuz.com/journey-from-containerization-to-orchestration-and-beyond/orchestration.png)  

（2）pod创建流程    

![preview](https://pic2.zhimg.com/v2-526ad710d1f47a559137acd8bcf1f859_r.jpg)



（4）https://juejin.im/post/5daf8b536fb9a04ddc625867（自定义scheduler 优选策略）

（5）kubernetes简介（https://kubernetes.feisky.xyz/）

​		kubernetes是谷歌开源的容器集群管理系统，主要功能包括:

（1）基于容器的应用部署、运维和滚动升级；

（2）负载均衡和服务发现；

（3）跨机器和跨地区的集群调度；

（4）自动伸缩；

（5）无状态服务和有状态服务；

（6）插件机制保证扩展性；

由于开源的热度持续提升，k8s已经成为容器编排领域的领导者。

### 4. 云原生（一切皆为云资源）

​		通过微服务的方式开发应用，以容器进行部署，使用K8S等容器编排工具进行容器集群的管理，使得开发运维都面向K8S，这就是云原生。云原生可以方便的构建应用，并对应用进行完整的监控，以及在应用针对不同流量时能进行快速的扩容和缩容。

Thank you!

